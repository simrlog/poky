From 8bc07c3ba3a412bd6bb94ad8bad0d76801ec2c9f Mon Sep 17 00:00:00 2001
From: Saul Wold <saul.wold@windriver.com>
Date: Tue, 22 Mar 2022 12:11:45 -0700
Subject: [PATCH] depmod: Add support for excluding a directory

This adds support to depmod to enable a new exclude directive in
the depmod.d/exclude.conf configuration file. Currently depmod
already excludes directories named source or build. This change
will allow additional directories like .debug to be excluded also
via a new exclude directive.

depmod.d/exclude.conf example:
exclude	.debug

Upstream-Status: Submitted

Signed-off-by: Saul Wold <saul.wold@windriver.com>

%% original patch: 0001-depmod-Add-support-for-excluding-a-directory.patch
---
 man/depmod.d.xml | 14 +++++++++++++
 tools/depmod.c   | 54 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 68 insertions(+)

diff --git a/man/depmod.d.xml b/man/depmod.d.xml
index b315e93..9ab790a 100644
--- a/man/depmod.d.xml
+++ b/man/depmod.d.xml
@@ -131,6 +131,20 @@
           </para>
         </listitem>
       </varlistentry>
+      <varlistentry>
+        <term>external <replaceable>excludedir</replaceable>
+        </term>
+        <listitem>
+          <para>
+            This specifies the trailing directories that will be excluded
+            during the search for kernel modules.
+          </para>
+          <para>
+	    The <replaceable>excludedir</replaceable> the trailing directory
+	    to exclude
+          </para>
+        </listitem>
+      </varlistentry>
     </variablelist>
   </refsect1>
 
diff --git a/tools/depmod.c b/tools/depmod.c
index eb810b8..8b19ab6 100644
--- a/tools/depmod.c
+++ b/tools/depmod.c
@@ -458,6 +458,12 @@ struct cfg_external {
 	char path[];
 };
 
+struct cfg_exclude {
+	struct cfg_exclude *next;
+	size_t len;
+	char exclude_dir[];
+};
+
 struct cfg {
 	const char *kversion;
 	char dirname[PATH_MAX];
@@ -469,6 +475,7 @@ struct cfg {
 	struct cfg_override *overrides;
 	struct cfg_search *searches;
 	struct cfg_external *externals;
+	struct cfg_exclude *excludes;
 };
 
 static enum search_type cfg_define_search_type(const char *path)
@@ -580,6 +587,31 @@ static void cfg_external_free(struct cfg_external *ext)
 	free(ext);
 }
 
+static int cfg_exclude_add(struct cfg *cfg, const char *path)
+{
+	struct cfg_exclude *exc;
+	size_t len = strlen(path);
+
+	exc = malloc(sizeof(struct cfg_exclude) + len);
+	if (exc == NULL) {
+		ERR("exclude add: out of memory\n");
+		return -ENOMEM;
+	}
+	exc->len = len;
+	memcpy(exc->exclude_dir, path, len);
+
+	DBG("exclude add: %s\n", path);
+
+	exc->next = cfg->excludes;
+	cfg->excludes = exc;
+	return 0;
+}
+
+static void cfg_exclude_free(struct cfg_exclude *exc)
+{
+	free(exc);
+}
+
 static int cfg_kernel_matches(const struct cfg *cfg, const char *pattern)
 {
 	regex_t re;
@@ -657,6 +689,11 @@ static int cfg_file_parse(struct cfg *cfg, const char *filename)
 			}
 
 			cfg_external_add(cfg, dir);
+		} else if (streq(cmd, "exclude")) {
+			const char *sp;
+			while ((sp = strtok_r(NULL, "\t ", &saveptr)) != NULL) {
+				cfg_exclude_add(cfg, sp);
+			}
 		} else if (streq(cmd, "include")
 				|| streq(cmd, "make_map_files")) {
 			INF("%s:%u: command %s not implemented yet\n",
@@ -857,6 +894,12 @@ static void cfg_free(struct cfg *cfg)
 		cfg->externals = cfg->externals->next;
 		cfg_external_free(tmp);
 	}
+
+	while (cfg->excludes) {
+		struct cfg_exclude *tmp = cfg->excludes;
+		cfg->excludes = cfg->excludes->next;
+		cfg_exclude_free(tmp);
+	}
 }
 
 
@@ -1239,12 +1282,23 @@ static int depmod_modules_search_dir(struct depmod *depmod, DIR *d, size_t basel
 		const char *name = de->d_name;
 		size_t namelen;
 		uint8_t is_dir;
+	        struct cfg_exclude *exc;
+		int exclude = 0;
 
 		if (name[0] == '.' && (name[1] == '\0' ||
 				       (name[1] == '.' && name[2] == '\0')))
 			continue;
 		if (streq(name, "build") || streq(name, "source"))
 			continue;
+
+	        for (exc = depmod->cfg->excludes; exc != NULL; exc = exc->next) {
+			if (streq(name, exc->exclude_dir)) {
+				exclude = 1;
+			}
+		}
+		if (exclude)
+			continue;
+
 		namelen = strlen(name);
 		if (scratchbuf_alloc(s_path, baselen + namelen + 2) < 0) {
 			err = -ENOMEM;
-- 
2.31.1

